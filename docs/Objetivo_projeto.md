# üß† Projeto: Tabela Din√¢mica para Integra√ß√£o com IA

## üéØ Objetivo

Criar um mecanismo de **tabelas din√¢micas baseadas em metadados**, com o prop√≥sito de:
- **Descrever as tabelas do banco de dados Oracle** (nome, campos, chaves e v√≠nculos).  
- **Gerar consultas SQL din√¢micas** com **SqlKata + Dapper**.  
- **Permitir que uma IA (ex: ChatGPT, Copilot, modelo interno)** interprete e consulte o banco de dados com base nesses metadados, **sem precisar conhecer a estrutura real**.  

A meta √© criar uma **camada de abstra√ß√£o e intelig√™ncia de dados**, onde novas tabelas e relacionamentos possam ser adicionados **sem alterar o c√≥digo C#** ‚Äî apenas atualizando os registros de metadados.

---

## üèóÔ∏è Arquitetura da Solu√ß√£o

### 1. Tabela de Metadados (`TABELA_DINAMICA`)

Tabela armazenada no Oracle, respons√°vel por descrever as entidades do sistema.

```sql
CREATE TABLE TABELA_DINAMICA (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    TABELA VARCHAR2(100),
    CAMPOS_DISPONIVEIS VARCHAR2(1000),
    CHAVE_PK VARCHAR2(100),
    VINCULO_ENTRE_TABELA VARCHAR2(200),
    DESCRICAO_TABELA VARCHAR2(500),
    DESCRICAO_CAMPOS CLOB,      -- JSON opcional com descri√ß√µes detalhadas de cada campo
    VISIVEL_PARA_IA CHAR(1) DEFAULT 'S'  -- controle de visibilidade para IA
);
```

### Exemplo de dados

| TABELA | CAMPOS_DISPONIVEIS | CHAVE_PK | VINCULO_ENTRE_TABELA | DESCRICAO_TABELA |
|--------|--------------------|-----------|-----------------------|------------------|
| Pedido | Id, pedido, data_pedido, produto_id | Id | null | Representa os pedidos de venda |
| Produto | Id, codigo, nome | Id | Pedido.produto_id | Representa os produtos vendidos |

---

### 2. Classe de Modelo (`TabelaDinamica.cs`)

```csharp
public class TabelaDinamica
{
    public string Tabela { get; set; }
    public string Campos_Disponiveis { get; set; }
    public string Chave_PK { get; set; }
    public string Vinculo_Entre_Tabela { get; set; }
    public string Descricao_Tabela { get; set; }
    public string Descricao_Campos { get; set; }
    public string Visivel_Para_IA { get; set; }
}
```

---

### 3. Builder de Consultas Din√¢micas (`QueryBuilderDinamico`)

Classe respons√°vel por montar **consultas SQL autom√°ticas** a partir dos metadados.

**Fun√ß√µes principais:**
- Ler os metadados com Dapper.  
- Montar consultas `SELECT` din√¢micas usando SqlKata.  
- Adicionar `JOINs` automaticamente com base nos v√≠nculos.  
- Permitir consultas recursivas (ex: Pedido ‚Üí Produto ‚Üí Categoria).  

```csharp
public class QueryBuilderDinamico
{
    private readonly QueryFactory _db;
    private readonly List<TabelaDinamica> _tabelasMeta;

    public QueryBuilderDinamico(IDbConnection connection, Compiler compiler)
    {
        _db = new QueryFactory(connection, compiler);
        _tabelasMeta = _db.Connection.Query<TabelaDinamica>("SELECT * FROM TABELA_DINAMICA").ToList();
    }

    public Query MontarQuery(string tabelaBase)
    {
        var tabela = _tabelasMeta.FirstOrDefault(t => t.Tabela == tabelaBase)
            ?? throw new Exception($"Tabela {tabelaBase} n√£o encontrada.");

        var query = _db.Query(tabela.Tabela);
        query.Select(tabela.Campos_Disponiveis.Split(',').Select(c => $"{tabela.Tabela}.{c.Trim()}"));
        AdicionarJoins(query, tabela);

        return query;
    }

    private void AdicionarJoins(Query query, TabelaDinamica tabelaAtual)
    {
        var filhas = _tabelasMeta
            .Where(t => t.Vinculo_Entre_Tabela?.StartsWith(tabelaAtual.Tabela + ".") == true);

        foreach (var filha in filhas)
        {
            var partes = filha.Vinculo_Entre_Tabela.Split('.');
            if (partes.Length != 2) continue;

            query.Join(filha.Tabela,
                $"{filha.Tabela}.{filha.Chave_PK}",
                $"{tabelaAtual.Tabela}.{partes[1]}");

            query.Select(filha.Campos_Disponiveis.Split(',')
                .Select(c => $"{filha.Tabela}.{c.Trim()}"));

            AdicionarJoins(query, filha);
        }
    }
}
```

---

### 4. Servi√ßo de Cat√°logo para IA (`IADataCatalogService`)

Respons√°vel por montar o **contexto textual** que ser√° enviado √† IA ‚Äî descrevendo todas as tabelas e v√≠nculos dispon√≠veis.

```csharp
public class IADataCatalogService
{
    private readonly List<TabelaDinamica> _meta;

    public IADataCatalogService(IDbConnection connection)
    {
        _meta = connection.Query<TabelaDinamica>(
            "SELECT * FROM TABELA_DINAMICA WHERE VISIVEL_PARA_IA = 'S'").ToList();
    }

    public string GerarPromptParaIA()
    {
        var sb = new StringBuilder();
        sb.AppendLine("Voc√™ √© uma IA que entende o modelo de dados abaixo e deve responder em SQL ou explica√ß√µes:");
        sb.AppendLine();

        foreach (var t in _meta)
        {
            sb.AppendLine($"TABELA: {t.Tabela}");
            sb.AppendLine($"DESCRI√á√ÉO: {t.Descricao_Tabela}");
            sb.AppendLine($"CAMPOS DISPON√çVEIS: {t.Campos_Disponiveis}");
            sb.AppendLine($"CHAVE PK: {t.Chave_PK}");
            if (!string.IsNullOrEmpty(t.Vinculo_Entre_Tabela))
                sb.AppendLine($"V√çNCULOS: {t.Vinculo_Entre_Tabela}");
            sb.AppendLine();
        }

        sb.AppendLine("Sempre use apenas as tabelas e campos descritos acima.");
        return sb.ToString();
    }
}
```

---

## üß© Fluxo de Integra√ß√£o com IA

1. O sistema gera o prompt base com `IADataCatalogService`.  
2. A IA recebe o cat√°logo de metadados e entende o modelo relacional.  
3. O usu√°rio faz perguntas em linguagem natural (ex: ‚ÄúListe os pedidos com nome do produto‚Äù).  
4. A IA monta uma query SQL com base no cat√°logo.  
5. O sistema executa a query com SqlKata/Dapper e retorna os dados.  

---

## üß† Benef√≠cios da abordagem

| Benef√≠cio | Descri√ß√£o |
|------------|------------|
| **Flexibilidade total** | Novas tabelas e campos podem ser adicionados sem alterar o c√≥digo. |
| **Camada sem√¢ntica para IA** | A IA entende o modelo e os v√≠nculos de forma descritiva. |
| **Seguran√ßa** | Voc√™ controla quais tabelas e campos s√£o vis√≠veis para a IA. |
| **Reuso de l√≥gica** | SqlKata e Dapper permitem gerar SQL limpo e port√°til. |
| **Escalabilidade** | Ideal para cen√°rios de analytics, relat√≥rios e chatbots corporativos. |

---

## ‚ö†Ô∏è Boas pr√°ticas e observa√ß√µes

- üîí **Nunca exponha o banco real diretamente √† IA** ‚Äî use sempre a camada de metadados e valida√ß√£o.  
- üß© **Valide v√≠nculos** ao cadastrar novas tabelas (garantir que campos e chaves existem).  
- üìò **Documente** cada tabela com descri√ß√µes claras (√∫til para a IA e para humanos).  
- ‚öôÔ∏è **Cache** o cat√°logo de metadados em mem√≥ria para performance.  
- üß± **Extens√£o futura:**  
  - Campo `TIPO_RELACIONAMENTO` (INNER, LEFT, etc)  
  - Campo `ALIAS_TABELA` para nomes amig√°veis  
  - Integra√ß√£o com embeddings sem√¢nticos (para IA entender nomes parecidos, ex: ‚Äúpedido‚Äù ‚âà ‚Äúordem‚Äù)  

---

## üó∫Ô∏è Roadmap (Pr√≥ximos Passos)

1. **Valida√ß√£o autom√°tica de metadados**
   - Criar script que verifica se cada `TABELA` e `CAMPOS_DISPONIVEIS` existem no Oracle.
   - Validar v√≠nculos (`VINCULO_ENTRE_TABELA`) com base em chaves prim√°rias e estrangeiras.

2. **Interface administrativa**
   - Criar tela para gerenciar `TABELA_DINAMICA` (CRUD completo, com valida√ß√£o e autocomplete de colunas).

3. **Gera√ß√£o autom√°tica de documenta√ß√£o**
   - Gerar arquivos `.md` com descri√ß√µes de tabelas e rela√ß√µes a partir da `TABELA_DINAMICA`.

4. **Integra√ß√£o com IA**
   - Criar endpoint que envia o prompt gerado para o modelo de IA (ChatGPT API, Copilot ou modelo local).
   - IA responde com SQL ou texto explicativo, o sistema executa e retorna os dados.

5. **Expans√£o sem√¢ntica**
   - Adicionar camada de sin√¥nimos ou embeddings (ex: ‚Äúcliente‚Äù ‚âà ‚Äúcomprador‚Äù) para IA compreender termos alternativos.

---

## ‚úÖ Resumo final

> A ‚ÄúTabela Din√¢mica‚Äù √© uma **camada de metadados inteligente**, que descreve as estruturas do banco e permite que uma **IA compreenda e consulte dados corporativos de forma segura, flex√≠vel e expans√≠vel**.  
>  
> Essa arquitetura une **metadados relacionais + gera√ß√£o din√¢mica de SQL + IA conversacional**, criando um ambiente onde **novas entidades podem ser adicionadas apenas por configura√ß√£o**, sem modificar o c√≥digo-fonte.
